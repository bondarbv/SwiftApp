//
//  DataManager.swift
//  SwiftApp
//
//  Created by Bohdan on 14.11.2021.
//

import Foundation

class DataManager {
    
    static let shared = DataManager()
    
    // MARK: - Data types question
    let dataTypesEasyQuestions: [String] = [
        "Тип данных String обеспечивает хранение отдельных символов/нет",
        "var isVisible = false - создаёт переменную типа Bool/да",
        "Можно ли использовать параметр до инициализации ему значения?/нет"
    ]
    
    let dataTypesMiddleQuestions: [String] = [
        "let size = '14.0' создается параметр типа Float/нет",
        "var thisIsMyVar: String = '' - явное определение типа данных/да",
        "Тип данных определяет значение и операции со значением/да"
    ]
    
    let dataTypesHardQuestions: [String] = [
        "Являются ли фундаментальные типы Bool, String и Int хешируемыми?/да",
        "Тип данных Int имеет 16-ти битную разрядность/нет",
        "Приведение - механизм, позволяющий преобразовать один тип данных в другой/да"
    ]
    
    // MARK: - Operators questions
    let operatorsEasyQuestions: [String] = [
        "break - пропускает итерацию, continue - выходит из цикла/нет",
        "repeat while и for позволяют многократно исполнять определенный блок кода/да",
        "В Swift есть операторы исключения выполнения/нет"
    ]
    
    let operatorsMiddleQuestions: [String] = [
        "Может ли оператор присваивания возвращать значение/нет",
        "Тернарные операторы - операторы, применяемые к 3м величинам/да",
        "Постфиксные - операторы, которые ставятся сразу за величиной/да"
    ]
    
    let operatorsHardQuestions: [String] = [
        "Swift поддерживает 6 операторов сравнения/да",
        "Можно ли сравнивать между собой два кортежа с типом (String, Bool)?/нет",
        "выражение ? действие1 : действие2 - бинарный условный оператор/нет"
    ]
    
    // MARK: - Arrays questions
    let arraysEasyQuestions: [String] = [
        "Для доступа к элементам массива мы оспользуем индекс/да",
        "Массив - упорядоченная коллекция однотипных элементов/да",
        "Если массив присвоен константе, можем ли мы добавить новые элементы?/нет"
    ]
    
    let arraysMiddleQuestions: [String] = [
        "Цикл for-in выполняет самое простое итерирование массива/да",
        "array.removeLast() - позволяет удалить последний элемент массива и сразу вернуть его/да",
        ".append - добавляет элемент в конец массива/да"
    ]
    
    let arraysHardQuestions: [String] = [
        "var array = (String)[] - создаёт пустой массив/нет",
        "Свойство .insert позволяет создать новый массив, объеденив два массива с совместимыми типами/нет",
        "Метод add(_ :at:) позволяет вставить элемент в массив на определённый индекс/нет"
    ]
    
    // MARK: - Optionals questions
    let optionalsEasyQuestions: [String] = [
        "Опциональный тип данных позволяет переменной или константе иметь какое-либо четко определенное значение, или не иметь его вовсе/да",
        "Значение целочисленного опционального типа может быть сложено со значением типа Int без дополнительных преобразований/нет",
        "Опционалы позволяют смоделировать ситуацию отсутствия значения в параметре/ да"
    ]
    
    let optionalsMiddleQuestions: [String] = [
        "Можем ли мы использовать значение с типом Int? как операнд в математической операции/нет",
        "String! является неявно извлечённым опционалом/да",
        "Мы используем ?? для принудительного извлечения опционала/нет"
    ]
    
    let optionalsHardQuestions: [String] = [
        "Сравнивая с nil через if мы можем проверить, содержит ли опционал значение/да",
        "Когда попытаемся получить доступ к неявно извлечённому опционалу, когда он не содержит значания, мы получим Runtime error/да",
        "Если мы точно уверены, что опционал имеет значение, наиболее быстрый способ получить его - принудительное извлечение(!)/да"
    ]
    
    // MARK: - Closures questions
    let closuresEasyQuestions: [String] = [
        "Является ли функция, возвращающее значение, замыканием?/да",
        "Может ли замыкание быть результатом вызова функции (возвращено функцией после исполнения)?/да",
        "Ключевое слово in в замыкании указывает на то, что далее следует тело замыкания?/ да"
    ]
    
    let closuresMiddleQuestions: [String] = [
        "метод sort позволяет отсортировать массив значений на основании переданного в него замыкания/ да",
        "Могут ли замыкания возвращать коллекции и кортежи в качестве возвращаемых значений?/да",
        "Мы удаляем элемент массива кодом внктри замыкания, будет ли он удалён, если мы не вызывали это замыкание?/нет"
    ]
    
    let closuresHardQuestions: [String] = [
        "Можем ли мы опустить функциональный тип тип замыкающего выражения?/да",
        "Можем ли мы передать значения по умолчанию в синтаксис замыканий?/нет",
        "Вложенные функции - замыкания, у которых есть имя и которые могут захватывать значения из включающей их функции/да"
    ]
    
}
